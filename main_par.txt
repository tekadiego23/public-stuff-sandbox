import os
import logging
import asyncio
from concurrent.futures import ThreadPoolExecutor

from fastapi import FastAPI
import requests
from urllib3.util.retry import Retry
from requests.adapters import HTTPAdapter

logger = logging.getLogger(__name__)

# -----------------------
# Config perf
# -----------------------
REQUEST_TIMEOUT = float(os.getenv("REQUEST_TIMEOUT", "60"))  # s
MAX_CONNECTIONS = int(os.getenv("MAX_CONNECTIONS", "600"))   # >= nb req parallèles
MAX_KEEPALIVE  = int(os.getenv("MAX_KEEPALIVE",  "200"))
MAX_WORKERS    = int(os.getenv("MAX_WORKERS",    "800"))     # threadpool pour I/O sync + CPU

# -----------------------
# App
# -----------------------
app = FastAPI(
    root_path=f"/{os.getenv('ENV_SERVICE_ENTRY', '')}",
    swagger_ui_parameters={"syntaxHighlight": True},
)

# -----------------------
# Helpers
# -----------------------
def build_requests_session() -> requests.Session:
    """
    Session requests mutualisée, keep-alive, pool dimensionné, retries légers.
    """
    s = requests.Session()
    retry = Retry(
        total=2,
        backoff_factor=0.2,
        status_forcelist=(429, 500, 502, 503, 504),
        allowed_methods=False,      # réessaye aussi les POST si idempotent côté serveur
        raise_on_status=False,
    )
    adapter = HTTPAdapter(
        pool_connections=MAX_CONNECTIONS,
        pool_maxsize=MAX_CONNECTIONS,
        max_retries=retry,
    )
    s.mount("http://", adapter)
    s.mount("https://", adapter)
    s.headers.update({"Connection": "keep-alive"})
    return s

# -----------------------
# Lifecycle
# -----------------------
@app.on_event("startup")
async def startup() -> None:
    # ThreadPool large pour offloader *toute* I/O sync (lib externe) + passages CPU
    loop = asyncio.get_running_loop()
    loop.set_default_executor(ThreadPoolExecutor(max_workers=MAX_WORKERS))

    # Session requests partagée (utilisée par la lib externe via injection)
    app.state.requests_session = build_requests_session()

    logger.info(
        "Startup done. MAX_CONNECTIONS=%s MAX_KEEPALIVE=%s MAX_WORKERS=%s",
        MAX_CONNECTIONS, MAX_KEEPALIVE, MAX_WORKERS
    )

@app.on_event("shutdown")
async def shutdown() -> None:
    try:
        app.state.requests_session.close()
    except Exception:
        pass
